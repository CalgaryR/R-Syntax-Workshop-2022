---
title: "R Syntax"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
```

<!-- ======================== -->
## Basic Instructions
<!-- ======================== -->

Start in order with every section. A check mark will appear to the left of each section main header when you have completed the executing of the code or answered the questions, in the case of quizes.

If you want to restart the whole document erasing all of your previous history press the `Start Over` button on the left pane. Closing and reopening the document will restore all of your previous answers up to the point where you last closed it.

After completing all the exercises and questions under a topic a bar on the left of the main topic will indicate that you have completed it.

Let's get started.

<!-- ======================== -->
## R as a calculator
<!-- ======================== -->

R has a console to interact with it. Let's use it as a calculator to add two numbers. 

Run the line of code to add two plus two:

```{r two-plus-two, exercise=TRUE}
2 + 2
```

Note the output, there is a [1] and the result of the calculation. We will address the meaning of the number between square brackets shortly. For now pretend it tells you the position of the single answer provided: a `[1]` indicates that the number `4` is the first value in the answer.

### Mathematical operators in R

Please try running the following lines of code representing mathematical  operations.

```{r operators-1, exercise=TRUE}
450 - 100
3 * 10
35 / 7
5^2
```

Each result appears on its own line after running the code. This is the same behaviour you would see on a command line if you entererd the four lines of code.

### Operator precedence

Operators that act on a single value are _unary_ while those that receive two arguments are _binary_. The execution order of an expression containing several operators follows the rules of operator precedence that give more or less priority to some operators over others. Compare the following two lines:

```{r op-precendence, exercise=TRUE}
1 + 5 * 5
(1 + 5) * 5
```

Multiplication takes precendence over addition when the first line is evaluated. The use of parenthesis forces the addition to be carried out before the final multiplication by `5` on the second line.

From the R help here is a list of all the unary and binary operators and their precedence from highest to lowest from top to bottom and from left to right within groups:

```{r op-precedence-2, results='asis'}
library(knitr)
kable(data.frame(operator_groups = c(":: :::",
                               "$ @",
                               "[ [[",
                               "^",
                               "- +",
                               ":",
                               "%any%",
                               "* /",
                               "+ -",
                               "< > <= >= == !=",
                               "!",
                               "& &&",
                               "| ||",
                               "~",
                               "-> ->>",
                               "<- <<-",
                               "=",
                               "?"),
description = c("access variables in a namespace",
                "component / slot extraction",
                "indexing",
                "exponentiation (right to left)",
                "unary minus and plus",
                "sequence operator",
                "special operators (including %% and %/%)",
                "multiply, divide",
                "(binary) add, subtract",
                "ordering and comparison",
                "negation",
                "and",
                "or",
                "as in formulae",
                "rightwards assignment",
                "assignment (right to left)",
                "assignment (right to left)",
                "help (unary and binary)")))
```

You can get documentation like this from the R help at the comamnd line by typing `?Syntax` or `help("Syntax")`, note the double quotes in the second comamnd. 

### Storing values in variables

It's a good idea to store results in variables so we can keep them around and do additional operations with them in other expressions.

```{r storing-values, exercise=TRUE}
a <- 10
b <- a + 10
```

The _<-_ binary operator indicates assignment. The value on the right is assigned to the variable on the left. After line 1 is executed by R the variable `a` stores the value 10 so when the second line is executed b is assigned he result of applying the operator `+` to the value `10` and the value of the variable `a`. As a result of all this `b` will be assigned the value `20`.

### Built-in functions

R offers predefined functions that may take arguments and return computed values when executed. These functions may be part of expressions intended to store in variables the result of evaluating the functions with specific arguments. Let's look at the result of running the following lines:

```{r executing-function, exercise.lines=2, exercise=TRUE}
e <- exp(1)
e
```

The value stored in the variable `e` gets printed as `2.718282` when we run the second line with the expression `e`, as expected. Try running the line 1 by itself.

```{r executing-function-oneline, exercise.lines=1, exercise=TRUE}
e <- exp(1)
```

There should be no output. The value of the function `exp` with the argument `1` was computed and stored in the variable called `e`. The assignment operation leaves no trace on the output. Another way of saying this is _the assignment operator produces no side efects in the console_. Its only effect is to create a name-value pair in the global environment, so the value can be recalled later by its assigned name.

### Other built-in functions

To compute logarithms, R offers the following predefined functions:

```
     log(x, base = exp(1))
     logb(x, base = exp(1))
     log10(x)
     log2(x)
     
     log1p(x)
```
To see all the predefined functions available in the base package type `library(help = "base)` at the command line.

```{r functions-base-package, exercise=TRUE}
library(help = "base")
```

### The assignment operators and their uses

Experiment now to compute logarithms in base 10 and natural logarithms (base _e_). Try to answer the following: 

 - What is the logarithm of 10 in base 10?
 - What is the natural logarithm of _e_?
 - What is the logarithm of 512 in base 2?
 
Try using the two variables already predefined in the first two lines. Add as many lines of code as you need to experiment.

```{r other-operators, exercise=TRUE, exercise.lines=12}
a <- 10
e = exp(1)

print(paste0("a = ", a, "; e = ", round( x = e, digits = 4)))

# logarithm of 10 in base 10

# natural logarithm of e

# binary logarithm of 512

```

```{r other-operators-hint}
log10(a)
log(e, base = e)
```

From the previous exercise you might have noticed that the operators `<-` and `=` behave identically in stand alone expressions. Technically speaking, their effect is to create name-value pairs for each variable, (_a_, 10) and (_e_, 2.7183), in the global environment.

So, you might ask: why are there two aperators to do the same in R?
Read on for the answer.

### Function arguments: positional and named 

R functions may be built-in or user created, they may have also none, one, or more arguments. The arguments are given in between parenthesis, separated by commas, and they may be named or not. An example of a named parameter to a function is `base` in the `log` function: `log(x, base = exp(1))`. Examine the code below and guess the output before running it, did you expect the result?

```{r named-param-1, exercise = TRUE, exercise.lines=9}
three <- log(1000, base = 10)

# Does 'base' exist in the global environment after log gest evaluated?
# let's  check it out and print a nice message accordingly
if (exists("base")) {
  print(paste0("base exists outside of log, base = ", base)) 
} else {
  print("base does not exist outside of log")
}
```

In the call to the function `log`, the first argument is positional, taking exactly the position number one. The second argument is named and may receive a value via the `=` operator if the function requires it during its execution.

If the function is called without a second argument, and `base` is used for computation inside the function, the assignment operator will use the value resulting from evaluating the experession `exp(1)` and associate it with `base`. This is  how a default value for a named argument can be given. 

If the user prefers to pass a different value from the default then the named argument can be given as in `log(10, base = 10)` or just  `log(10, 10)`. 

```{r named-param-2, exercise = TRUE}
# use the name for the second argument
log(1000, base = 10)
# use only a value for the second argument, still ok!
log(1000, 10)
```

Now compare the flexibility of using the explicit name assignment.

```{r named-param-3, exercise = TRUE}
# the first argument is now a named argument so the second gets position one instead
log(base = 10, 1000)
# in absence of hints x = 10 (position one) and base = 1000 (named)
log(10, 1000)
```

### More on variable assignment

We already saw how the `=` operator for a named argument does not affect the global environment where the function is created. Variable assignment is like creating a pair (variable-name, expression) that lives in a scope where it can be reached for further evaluation.

We could use the `<-` operator for the named argument, the expression `log(x, base <- exp(1))` would assign the expression `exp(1)` to the local variable `base`. However, before that gets done, the name-expression pair gets created in the global environment. That implies that there will be a global variable `base` with the value of evaluating `exp(1)` outside of the function `log` after exiting `log`. Let's test that. 

```{r named-param-4, exercise = TRUE}
log(1000, base <- 10)
# Does 'base' exist in the global environment after log gest evaluated?
if (exists("base")) {
  print(paste0("base exists outside of log, base = ", base)) 
} else {
  print("base does not exist outside of log")
}
```

If we use the global assignment operator `<-` in the first position it might have an unexpected result compared to using the local assignemnt operator `=`.  Check for yourself with the code below.

```{r named-param-5, exercise = TRUE}
log(base <- 10, 1000)
```

Did you get the same result of using `log(base = 10, 1000)`? That is almost true, the difference is that now there is a variable assignment represented by the pair `(base, 10)` that outlives the call to `log`.

In summary, to avoid ambiguities and unplanned side effects, when assigning values to variables use `<-` for stand-alone expressions and `=` for function named parameters. On the next section there are a few exercises to solidifiy these concepts.


<!-- ======================== -->
## Test your understanding
<!-- ======================== -->

```{r quiz-1-a, echo=FALSE, cache=FALSE}
quiz(
  question("Consider the expression: 
  
            a <- 1 + log10(10)
  
  What is the result of executing the line above in the R console?",
    answer("the value 2 gets assigned to _a_ and printed to the console", message = "the operaror _assignment_ has no side effects so nothing should be printed to the console"),
    answer("error, _log10_ of 10 is undefined", message = "That's not quite right, check your the definition of a logarithm and try again"),
    answer("nothing gets printed", correct = TRUE, message = "The operator _assignment_ has no side effects so nothing gest printed after the value 2 gets associated with the variable _a_"),
    answer("the value of _a_ gets printed", message = "The operator _assignment_ has no other effect than to associate a value with a variable name"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("What is the result of executing
           
           10 - 6 / 2 ?",
    answer("2", message = "division has precedence over subtraction"),
    answer("7", correct = TRUE, message = "division has higher precedence than subtraction"),
    answer("8", message = "Good try, redo the calculation"),
    answer("-4"),
  allow_retry = TRUE,
  random_answer_order = TRUE    
  ))
```


```{r quiz-1-c, echo=FALSE, cache=FALSE}
quiz(
  question("What is the value of b after executing the following R code?
  
          a <- 5
  
          b <- a * (34 - 22) / 1 + 1",
  answer("12"),
  answer("30"),
  answer("61", correct = TRUE),
  answer("149"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  try_again = "Check the operator precedence table and try again."
))
```



<!-- Every computing language uses a model to represent information in memory. R is no exception.  -->

<!-- Everything in R is an object with a default constructor. -->
<!-- There are two types of data structures according to what they data types they can store: homogeneous and heterogeneous. They can also be categorized according to the dimensions they can store: 1d, 2d or nd. -->

<!-- *The first homogeneous 1d structure is an atomic vector.* -->

<!-- ### Exercise with Code -->

<!-- *Here's an exercise with some prepopulated code as well as `exercise.lines = 5` to provide a bit more initial room to work.* -->

<!-- Now write a function that adds any two numbers and then call it: -->

<!-- ```{r add-function, exercise=TRUE, exercise.lines = 5} -->
<!-- add <- function() { -->

<!-- } -->
<!-- ``` -->



