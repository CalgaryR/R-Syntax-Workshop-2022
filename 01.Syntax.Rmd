---
title: "R Syntax"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: bib.bib
description: "Basic R Syntax and data structures"
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
```

<!-- ======================== -->
## Basic Instructions
<!-- ======================== -->

Start in order with every topic as they appear on the left panel. A bar on the left of each title will indicate that you have completed it. In addition to presenting explanations, code examples and code exercises, some sections may contain a quiz to test your understanding of the material. Completing a section means, having clicked through all the subsections, ran all the code exercises, or having answered all the questions.

As you work through each section, press the `Continue` button at the botton of the screen after covering each subsection. New subsections will appear until you reach the end of the section. The tutorial will not block you if you skip the exercises and you can also click on the next section on the left panel at any time. It is in your best interest that you go through them all, however life can get busy or you may be just reviewing a specific item, so feel free to browse at your pace. Just be warned, the material will make more sense if covered in sequential order the first time.

If you want to reset the state of your answers and the code  you've run on the exercises, erasing all of your previous history, press the `Start Over` option at the bottom left on the main panel. If you are following this material on a browser, reopening the page after having closed it will continue the previous session so you will maintain all of your answers up to the point where you last worked on it.

Let's get started.

<!-- ======================== -->
## R as a calculator
<!-- ======================== -->

R has a console to interact with it. Let's use it as a calculator to add two numbers. 

Run the line of code to add two plus two:

```{r two-plus-two, exercise=TRUE}
2 + 2
```

Note the output, there is a [1] and the result of the calculation. We will address the meaning of the number between square brackets shortly. For now pretend it tells you the position of the single answer provided: a `[1]` indicates that the number `4` is the first value in the answer.

### Mathematical operators in R

Please try running the following lines of code representing mathematical  operations.

```{r operators-1, exercise=TRUE}
450 - 100
3 * 10
35 / 7
5^2
```

Each result appears on its own line after running the code. This is the same behaviour you would see on a command line if you entererd the four lines of code.

### Operator precedence

Operators that act on a single value are _unary_ while those that receive two arguments are _binary_. The execution order of an expression containing several operators follows the rules of operator precedence that give more or less priority to some operators over others. Compare the following two lines:

```{r op-precendence, exercise=TRUE}
1 + 5 * 5
(1 + 5) * 5
```

Multiplication takes precendence over addition when the first line is evaluated. The use of parenthesis forces the addition to be carried out before the final multiplication by `5` on the second line.

From the R help here is a list of all the unary and binary operators and their precedence from highest to lowest from top to bottom and from left to right within groups:

```{r op-precedence-2, results='asis'}
library(knitr)
kable(data.frame(operator_groups = c(":: :::",
                               "$ @",
                               "[ [[",
                               "^",
                               "- +",
                               ":",
                               "%any%",
                               "* /",
                               "+ -",
                               "< > <= >= == !=",
                               "!",
                               "& &&",
                               "| ||",
                               "~",
                               "-> ->>",
                               "<- <<-",
                               "=",
                               "?"),
description = c("access variables in a namespace",
                "component / slot extraction",
                "indexing",
                "exponentiation (right to left)",
                "unary minus and plus",
                "sequence operator",
                "special operators (including %% and %/%)",
                "multiply, divide",
                "(binary) add, subtract",
                "ordering and comparison",
                "negation",
                "and",
                "or",
                "as in formulae",
                "rightwards assignment",
                "assignment (right to left)",
                "assignment (right to left)",
                "help (unary and binary)")))
```

You can get documentation like this from the R help at the comamnd line by typing `?Syntax` or `help("Syntax")`, a full set of help functions appears on the table below. 

```{r help-commands, echo=FALSE, results='asis'}
library(knitr)
long_form <- c("help.start()", "help(\"funABC\")", "help.search(\"funABC\")", "example(\"funABC\")", "RSiteSearch()","apropos(\"funABC\", mode = \"function\")", "data()", "vignette()", "vignette(\"ABC\")") 
short_form <- c("", "?funABC", "??funABC", "", "", "", "", "", "")
description = c("General help system",
                "Help on function \"funABC\" (quotations optional)",
                "Searches help for string \"funABC\"",
                "Finds examples for \"funABC\"",
                "Opens a browser search for \"funABC\" on R online manuals and archived mailing lists",
                "List of all avaliable functions with \"funABC\" in their name",
                "List all data sets in loaded packages",
                "List vignettes for currently installed packages",
                "Displays content of vignette for package \"ABC\"")

kable( data.frame(long_form, short_form, description, 
                 stringsAsFactors = FALSE),
       caption = 'Help commands explained [@KabacoffRobert2015Ria, p.11]')
```

### Storing values in variables

It's a good idea to store results in variables so we can keep them around to use them in other expressions.

```{r storing-values, exercise=TRUE}
a <- 10
b <- a + 10
```

The `<-` binary operator indicates assignment. The value on the right is assigned to the variable on the left. After line 1 is executed by R the variable `a` stores the value 10 so when the second line is executed b is assigned he result of applying the operator `+` to the value `10` and the value of the variable `a`. As a result of all this `b` will be assigned the value `20`.

### Built-in functions

R offers predefined functions. These may take arguments and return computed values when executed. Some expressions may take a function with arguments and store the returned value for storage in a variable. Let's look at the result of running the following lines:

```{r executing-function, exercise.lines=2, exercise=TRUE}
e <- exp(1)
e
```

The first line executes the expression on the right of the assignment operator, itself a function call to `exp()` with argument `1` and assignes the returned value to the variable `e`. The second line prints the value stored in `e` as `2.718282`.

Try running the line 1 by itself below.

```{r executing-function-oneline, exercise.lines=1, exercise=TRUE}
e <- exp(1)
```

There should be no output. The value of the function `exp` with the argument `1` was computed and stored in the variable `e`. The assignment operation leaves no trace on the output. Another way of saying this is _the assignment operator produces no side efects in the console_. Its only effect is to create a name-value pair, (e, 2.718282) in the global environment, so the value can be recalled later by its assigned name.

*Note:* As it is usually the case in R, there is a way to get more millage out of your code. You can get a two-for-one effect by printing and doing assignment in a single expression on the console by surrounding the assignment with parenthesis. Try it!

```{r two-for-one,  exercise = TRUE}
(e <- exp(1))
e
```

### Other built-in functions

To compute logarithms, R offers the following predefined functions:

```
     log(x, base = exp(1))
     logb(x, base = exp(1))
     log10(x)
     log2(x)
     
     log1p(x)
```
To see all the predefined functions available in the base package type `library(help = "base)` at the command line.

```{r functions-base-package, exercise=TRUE}
library(help = "base")
```

### The assignment operators and their uses

Experiment now to compute logarithms in base 10 and natural logarithms (base _e_). Try to answer the following: 

 - What is the logarithm of 10 in base 10?
 - What is the natural logarithm of _e_?
 - What is the logarithm of 512 in base 2?
 
Try using the two variables already predefined in the first two lines. Add as many lines of code as you need to experiment.

```{r other-operators, exercise=TRUE, exercise.lines=12}
a <- 10
e = exp(1)

print(paste0("a = ", a, "; e = ", round( x = e, digits = 4)))

# logarithm of 10 in base 10

# natural logarithm of e

# binary logarithm of 512

```

```{r other-operators-hint}
log10(a)
log(e, base = e)
```

From the previous exercise you might have noticed that the operators `<-` and `=` behave identically in stand alone expressions. Technically speaking, their effect is to create name-value pairs for each variable, (_a_, 10) and (_e_, 2.7183), in the global environment.

So, you might ask: why are there two aperators to do the same in R?
Read on for the answer.

### Function arguments: positional and named 

R functions may be built-in or user created, they may have also none, one, or more arguments. The arguments are given in between parenthesis, separated by commas, and they may be named or not. An example of a named parameter to a function is `base` in the `log` function: `log(x, base = exp(1))`. Examine the code below and guess the output before running it, did you expect the result?

```{r named-param-1, exercise = TRUE, exercise.lines=9}
three <- log(1000, base = 10)

# Does 'base' exist in the global environment after log gest evaluated?
# let's  check it out and print a nice message accordingly
if (exists("base")) {
  print(paste0("base exists outside of log, base = ", base)) 
} else {
  print("base does not exist outside of log")
}
```

In the call to the function `log`, the first argument is positional, taking exactly the position number one. The second argument is named and may receive a value via the `=` operator if the function requires it during its execution.

If the function is called without a second argument, and `base` is used for computation inside the function, the assignment operator will use the value resulting from evaluating the experession `exp(1)` and associate it with `base`. This is  how a default value for a named argument can be given. 

If the user prefers to pass a different value from the default then the named argument can be given as in `log(10, base = 10)` or just  `log(10, 10)`. 

```{r named-param-2, exercise = TRUE}
# use the name for the second argument
log(1000, base = 10)
# use only a value for the second argument, still ok!
log(1000, 10)
```

Now compare the flexibility of using the explicit name assignment.

```{r named-param-3, exercise = TRUE}
# the first argument is now a named argument so the second gets position one instead
log(base = 10, 1000)
# in absence of hints x = 10 (position one) and base = 1000 (named)
log(10, 1000)
```

### More on variable assignment

We already saw how the `=` operator for a named argument does not affect the global environment where the function is created. Variable assignment is like creating a pair (variable-name, expression) that lives in a scope where it can be reached for further evaluation.

We could use the `<-` operator for the named argument, the expression `log(x, base <- exp(1))` would assign the expression `exp(1)` to the local variable `base`. However, before that gets done, the name-expression pair gets created in the global environment. That implies that there will be a global variable `base` with the value of evaluating `exp(1)` outside of the function `log` after exiting `log`. Let's test that. 

```{r named-param-4, exercise = TRUE}
log(1000, base <- 10)
# Does 'base' exist in the global environment after log gest evaluated?
if (exists("base")) {
  print(paste0("base exists outside of log, base = ", base)) 
} else {
  print("base does not exist outside of log")
}
```

If we use the global assignment operator `<-` in the first position it might have an unexpected result compared to using the local assignemnt operator `=`.  Check for yourself with the code below.

```{r named-param-5, exercise = TRUE}
log(base <- 10, 1000)
```

Did you get the same result of using `log(base = 10, 1000)`? That is almost true, the difference is that now there is a variable assignment represented by the pair `(base, 10)` that outlives the call to `log`.

In summary, to avoid ambiguities and unplanned side effects, when assigning values to variables use `<-` for stand-alone expressions and `=` for function named parameters. On the next section there are a few exercises to solidifiy these concepts.


<!-- ======================== -->
## Test your understanding
<!-- ======================== -->

```{r quiz-1-a, echo=FALSE, cache=FALSE}
quiz(
  question("Consider the expression: 
  
            a <- 1 + log10(10)
  
  What is the result of executing the line above in the R console?",
    answer("the value 2 gets assigned to _a_ and printed to the console", message = "the operaror _assignment_ has no side effects so nothing should be printed to the console"),
    answer("error, _log10_ of 10 is undefined", message = "That's not quite right, check your the definition of a logarithm and try again"),
    answer("nothing gets printed", correct = TRUE, message = "The operator _assignment_ has no side effects so nothing gest printed after the value 2 gets associated with the variable _a_"),
    answer("the value of _a_ gets printed", message = "The operator _assignment_ has no other effect than to associate a value with a variable name"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("What is the result of executing
           
           10 - 6 / 2 ?",
    answer("2", message = "division has precedence over subtraction"),
    answer("7", correct = TRUE, message = "division has higher precedence than subtraction"),
    answer("8", message = "Good try, redo the calculation"),
    answer("-4"),
  allow_retry = TRUE,
  random_answer_order = TRUE    
  ))
```


```{r quiz-1-c, echo=FALSE, cache=FALSE}
quiz(
  question("What is the value of b after executing the following R code?
  
          a <- 5
  
          b <- a * (34 - 22) / 1 + 1",
  answer("12"),
  answer("30"),
  answer("61", correct = TRUE),
  answer("149"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  try_again = "Check the operator precedence table and try again."
))
```

## Data Representation in R

Every computing language uses a model to represent information in memory and R is no exception. Everything in R is an object with a default constructor. These objects adopt the form of data structures to hold values that have data types. We will cover these definitions and woork with them in this section.

### Data Types

The fundamental values that R can represent and manipulate int he computer memory are:

  - integer
  - double (also called numeric)
  - character
  - logical
  
There are two less commonly used: _complex_ and _raw_ that we will leave for another time.

### Data Structures

There are two types of data structures according to what data types they can store: homogeneous and heterogeneous. They can also be categorized according to the dimensions they can store: 1d, 2d or nd. This produces the following double entry table. 

```{r data structures, echo=FALSE, results='asis'}
Homogeneous <- c("Atomic vector", "Matrix", "Array")
Heterogeneous <- c("List", "Data frame", "")

kable( data.frame(Homogeneous, Heterogeneous, 
                 row.names = c("1d", "2d", "nd"), 
                 stringsAsFactors = FALSE),
       caption = 'Native data structures in R according to the data type they can store and the number of dimensions they use [@WickhamHadley2015AR, p.13].')
```

### Vectors

The table we just saw should be read as follows: all one-dimensional data structures that contain objects of the same type are vectors, as in they are stored in contiguous memory. A vector of six integer values would be represented graphically as:

```{r vector, echo=FALSE, results='asis'}
knitr::include_graphics("images/vector.png")
```

And as code:
```{r vector-construction, echo=TRUE}
c(5, -1, 3, 0, -4, 1)
```

A vector is constructed with the function `c()` that takes a variable number of arguments. Once a vector has been constructed and assigned to a variable `x` its elements can be extracted with the subsetting operator `[]` like `x[1]` to subset the vector so it returns a vector with the first  element only.

Try to answer the questions with your code.

```{r vector-example, exercise = TRUE, exercise.lines=10}
x <- c(5, -1, 3, 0, -4, 1)

# extract the third element of x

# subtract the first element from the last and print the result

# compute the length of x

# compute the difference between the last and first elements using the length

```

```{r vector-example-hint, echo=TRUE}
x[3]
x[6] - x[1]
length(x)
x[length(x)] - x[1]
```

Creating vectors can become a tedious task so there are a number of techniques to lighten this burden. When we can or need to use patterns  to create them the functions `rep()` and `seq()` can be pretty helpful.

```{r seq-rep, echo=TRUE}
rep(-1, times = 10)
seq(1, 100, by = 5)
```

The binary operator `:` can be used with integer values as a short version of `seq(to, from)`.

```{r short-version-of-seq, echo=TRUE}
1:100
```

Note that the execution of the expression creates a vector of integers from 1 to 100. Now we can interpret the numbers in square brackets on the left of the output as the position of the first value presented in that line of the output. Therefor the last line of output begins with the 91st element of the vector, which happens to be the number 91 in the sequence.

Combining the binary operator `:` and the subsetting operator one can extract ranges of elements of a vector.

```{r subsetting-a-vector, echo=TRUE}
x <- c(5, -1, 3, 0, -4, 1)
x[1:4]
```


`rep` and `seq` can be combined to composed colorful patterns.

```{r rep-seq-mix, exercise=TRUE}
# repeat the sequence of digits twice
rep(seq(1,9), times = 2)
# repeat the sequence of digits two at a time
rep(seq(1:9), each = 2)
```

Remember a vector *must* have elements of the same homogeneous type.
So this is a valid vector of doubles:

```{r vector-of-doubles, echo = TRUE}
c(2.3, -0.54, 1.01, 10.8)
```

And this one contains character strings:

```{r  vector-characters, echo = TRUE}
c("Hello", "world", "in", "R!")
```

And finally here is a vector of logical symbols:

```{r vector-logiocals, echo = TRUE}
c(TRUE, T, 1, FALSE, F, 0)
```

`FALSE`, `F`, or `0` represent the negation of `TRUE`, `T`, or `1`. So they are logical values in R and be mixed and matched at will.


### An eye-opener to type cohersion in R

Vectors can be queried for their type with the function `typeof` in general or individually for each type.

```{r type-numeric-vector, exercise = TRUE}
v_dbl <- c(0, 1, 3)
c(is.integer(v_dbl), is.numeric(v_dbl), is.double(v_dbl))
typeof(v_dbl)
```

The characters that represent integers are automatically interpreted as doubles or numeric, the more general concept. In order to force the interpretation as integers (in case it is absolutely necessary) use `L` as a suffix. Run the following and compare the results:

```{r type-int-vetor, exercise=TRUE}
v_int <- c(0L, 1L, 3L)
c(is.integer(v_int), is.numeric(v_int), is.double(v_int))
typeof(v_int)
```

In general R will try to coherce the elements of a vector to the most general type possible, usually _character_.


### Vector attributes

Vector can also be interrogated for their class and their attributes.

```{r vectors-class, echo=TRUE}
# a vector of four truth values
v <- c(T, T, F, T)
# the same as typeof for this object
class(v)
# are there any attributes?
attributes(v)
```

Now let's create the vector with names that become an attribute of the vector object. Pay close attention to the results of running this code.

```{r vectors-names, echo=TRUE}
# a vector of four truth value for four logical propositions
v <- c(p1 = T, p2 = T, p3 = F, p4 = T)
attributes(v)
```

There are three important attributes if a vector: names, class, and dimension. Each can be accessed via a specific function and may have the `NULL` value by default.

```{r vector-attributes-by-accessor, echo=TRUE}
v <- c(p1 = T, p2 = T, p3 = F, p4 = T)
names(v)
class(v)
dim(v)
```

Names can be changed in place with the assignment operator. Run this code and compare the two vectors of names from `v` after creation and after the reassignment.

```{r assigning-vector-names, exercise=TRUE}
v <- c(p1 = T, p2 = T, p3 = F, p4 = T)
# check the original names
names(v)
# reassigned names
names(v) <- c("val1", "val2", "val3", "val4")
# new names
names(v)
# finally check the names of the vector with the summ of all the values
names(sum(v))
```


## User functions




Now write a function that adds any two numbers and then call it.

```{r add-function, exercise=TRUE, exercise.lines = 5}
add2numbers <- function(a, b) {
  
}
```

```{r add-function-hint}
add2numbers <- function(a, b) {
  return(a + b)
}
```

## References

