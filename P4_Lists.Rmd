---
title: "Introduction to R Syntax 2020"
pagetitle: "Part 4: Lists"
output:
  learnr::tutorial:
    theme: spacelab
    ace_theme: cobalt
    progressive: true
    allow_skip: true
    highlight: pygments
    toc: yes
    toc_depth: 2
    code_folding: hide
runtime: shiny_prerendered
bibliography: bib.bib
description: "Lists and its applications in R"
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
```

<!-- ======================== -->

## What you will learn

<!-- ======================== -->

By the end of this tutorial, you will know the basics of lists in R.
We will cover the nature of lists, their core role in the R language, the syntax to construct them, how to modify them, and how to inspect them.
You will reuse syntax from vectors and matrices that extend to lists.
Specifically you will re-visit recycling, sub-setting using the the `[` syntax or using logical masks, and we will introduce a new operator to select or sub-set lists, the `[[` operator.

Finally we will put in context the fact that a linear model is built upon a list in the R language.

<!-- ======================== -->

## About this tutorial

<!-- ======================== -->

This introductory tutorial about the base R syntax can be used as a presentation by an instructor or as a self-study guide.
It contains explanations, fully functional code boxes, and quizzes that make it very interactive.
If time allows during a guided session, the student can execute code to prod and test how the syntax works providing invaluable hands-on feedback.
The instructor may also ask short questions regarding the material.
Should you fall behind or need more time, please do so after the live session.
Actually this is very important in order to cement the concepts and test your understanding.

The emphasis of this tutorial is on why R works the way it does and less on being a reference manual or a source of recipes.
In doing so we hope to get you excited about this useful and expressive language.
R was designed from the ground up to be vectorized and object oriented.
Its aim is to be useful for both experts and beginners with the need to do computational statistics, data analysis and data visualization tasks.

Dr. Amelia McNamara describes three types of R Syntax [@RSyntax-Cheatsheet]: the dollar sign, the formula, and the Tidyverse.
These syntax are interchangeable, the important thing is to be consistent when using them.
The formula syntax tends to be more compact but less readable while the Tidyverse syntax is more readable but also more verbose.
We will initially focus on the dollar sign syntax.
Later we introduce the formula syntax and finally the tidyverse syntax.

This tutorial was built entirely in R using a package called `learnr`.
It was compiled to an html document using Rmarkdown syntax and the `Knitr` package.
If you receive the source code and have RStudio, you can render it as a fully interactive web page.
Using an Rstudio solution it can also be deployed on a ShinyR server.
You can also do these things and much more if you move forward in your R journey.

Finally, if you are following this material on a browser, every time you reopen this page the tutorial will be in the previous state you left it the last time you worked on it.
If you want to reset your answers and the code you've run on the exercises, erasing all of your previous history, press the `Start Over` option at the bottom left on the main panel.

Let's get started.


<!-- ====================== -->

## What are Lists?

<!-- ====================== -->

Lists are one-dimensional vector objects that can store information of heterogeneous type, a list can even contain other lists.
R's linear model object, with constructor `lm()`, is a list.
Lists are very versatile and are at the center of R's model and data handling capabilities.

## Constructing lists

Here is a graphical representation of a list with three components.

```{r list, echo=FALSE, results='asis'}
knitr::include_graphics("images/list.png", dpi = 96)
```

And here is your turn to create it with R code using the constructor `list()`.
Try to complete the exercise before looking at the hint.

```{r list-constructor, exercise=TRUE, exercise.lines=7}
my_list <- list(some_strings = c("hello", "world"),
                some_numbers = 10:15,
                some_booleans = c(T,T,T,F))
# check the names

# extract the first element of the list
```

```{r list-constructor-hint}
attributes(my_list)
names(my_list)
my_list[[1]]
```

## Accessing the elements of a list {#accessing-the-elements-of-a-list}

Did you notice the use of double square brackets, `[[]]` to access the vectors stored in the list of the previous section?
Had you chosen to use single brackets `[]` the result would have been a named list of one vector as its only element, try it now if you did not before:

```{r, subsettingListsSingleBracketSetup}
my_list <- list(some_strings = c("hello", "world"),
          some_numbers = 10:15,
          some_booleans = c(T,T,T,F))
```

```{r, subsetting-lists-single-bracket, exercise=T, exercise.lines=4, exercise.setup="subsettingListsSingleBracketSetup"}
my_list <- list(some_strings = c("hello", "world"),
          some_numbers = 10:15,
          some_booleans = c(T,T,T,F))
class(my_list[1])
my_list[1]
class(my_list[[1]])
my_list[[1]]
```

The list class is kind of a super set of the vector class, thus R's coercion philosophy will be to coerce vectors into lists whenever confronted with the dilemma.
In the following case, attempting to create a vector given a list and a vector, first coerces the vector into a list (a list is a more general concept than a vector) and then merges the two lists into a single one.

```{r, coercion-of-vector-to-list, exercise=T, exercise.lines=2}
new_object <- c(list(1,"a"), c(0,2,4))
new_object
```

In general, passing two or more lists as arguments to `c()` merges them all into a single list.

<!-- =========================== -->

## Appending a new element {#appending-a-new-element}

<!-- =========================== -->

In order to append a new element to an existing list the `c()` operator works well.
The caveat is to use the `list()` constructor around the new element.
This is useful to prevent the flattening of a vector into individual list elements when appended.
It creates a new object leaving the original list unchanged.

```{r, new-element-appending-in-new-list, exercise=T, exercise.lines=9, exercise.setup="subsettingListsSingleBracketSetup"}
length(my_list)
# this creates a new list
new_list <- c(my_list, list(rep(-1,3)))
# check the length of the original list
length(my_list)
# check the length of the new list
length(new_list)
# check that the last element is the vector we wanted to insert
new_list[[length(new_list)]]
```

The `[[]]` operator allows insertion of new elements of any type into a list, that means no coercion will be used.
This is the similar functionality of the operator `[]` for vectors.

```{r, new-element-of-list-appending-in-place, exercise=T, exercise.lines=7, exercise.setup="subsettingListsSingleBracketSetup"}
length(my_list)
# this modifies in place
my_list[[length(my_list) + 1]] <- rep(-1,3)
# check the new length of the list
length(my_list)
# check that the last element is the vector we wanted to insert
my_list[[length(my_list)]]
```

<!-- =============================== -->

### Accessing nested lists

<!-- =============================== -->

When passing lists as argument to the `list()` constructor there is no need for coercion of any kind.
Try the following code to make sure you grasp the concept.
This will become very important to do amazing data analysis later.

Would you have thought that R could come in handy for that party you are planning for friends and family?
The list of items for the party can be nested within the list of party items, how convenient!

```{r list-nesting, exercise=TRUE, exercise.lines=14}
# get organized for that party you are throwing for friends and family
party_items = list( drinks = c("pop", "wine", "beer", "water"),
                    furniture = c(chairs = 8, tables = 2, hammocks = 1))

(to_do_list <- list(guests = c("Uncle Bob", "Friendly neighbour", "Joe Best"),
                   invited = c(F,F,T),
                   items = party_items))

# extract the party items from the 'to_do_list' and display the drinks to buy

```

```{r list-nesting-hint}
to_do_list[[3]][[1]]
# equivalent but using the dollar operator
to_do_list[[3]]$drinks
# using the dollar operator all the way
to_do_list$items$drinks
```

<!-- =============================== -->

## Referencing elements by name

<!-- =============================== -->

From the exercise of the previous section we saw that either the `[[1]]` positional or the `$drinks` name syntax extract the vector stored at the list returned by `to_do_list[[3]]`.

The `$` operator can be used to reference named elements of a list.

Compare the effect of using single square brackets as opposed to the double square brackets on a list.

```{r, setupListOfLists}
party_items = list( drinks = c("pop", "wine", "beer", "water"),
                    furniture = c(chairs = 8, tables = 2, hammocks = 1))

to_do_list <- list(guests = c("Uncle Bob", "Friendly neighbour", "Joe Best"),
                   invited = c(F,F,T),
                   items = party_items)
```

```{r, example-list-from-a-list, exercise=T, exercise.lines=8, exercise.setup="setupListOfLists"}
# these two options are equivalent and return single element lists
to_do_list[2]
to_do_list["invited"]
class(to_do_list[2])
class(to_do_list["invited"])
# compare to the class of the object returned by
class(to_do_list[[2]])
class(to_do_list$invited)
```

```{r listDollarSetup}
party_items = list( drinks = c("pop", "wine", "beer", "water"),
                    furniture = c(chairs = 8, tables = 2, hammocks = 1))

to_do_list <- list(guests = c("Uncle Bob", "Friendly neighbour", "Joe Best"),
                   invited = c(F,F,T),
                   items = party_items)
```

Thanks to the `$` and assignment operators one can simplify printing the drinks for the party.

```{r list-dollar-show, exercise=TRUE, exercise.setup="listDollarSetup", exercise.lines=2 }
to_buy <- to_do_list$items
to_buy$drinks
```

<!-- =============================== -->

## Conversion of lists to vectors {#conversion-of-lists-to-vectors}

<!-- =============================== -->

A list can be coerced into a vector using the `unlist()` function.
It uses the same coercion rules that `c()` uses to create homogeneous types for each element.

```{r, using-unlist-to-convert-list-to-vector, exercise=T, exercise.lines=5}
set.seed(6728)
a_list <- list(labels=LETTERS[1:5], runs=1:5, outcomes=sample(1:10, size = 5))
str(a_list)
vector_version <- unlist(a_list)
str(vector_version)
```

<!-- =============================== -->

## Test your knowledge

<!-- =============================== -->

```{r quiz-lists, echo=FALSE, cache=FALSE}
quiz(
  question_radio(
    "The subsetting operator [ always returns a list when applied to a list.",
    answer("True", correct = TRUE),
    answer("False", correct = FALSE, message = "Well, mayve you were thinking of [[, that one gives you the actual elelment(s) of the list."),
    random_answer_order = TRUE,
    allow_retry = TRUE,
    correct = "You are on a roll! This is an important characteristic of lists."
  ),
  question_checkbox("Your rent went up by 3% this month. I know, this is a crazy neighbourhood.

          to_do <- list(errands = c(\"Doctor's appointment\",
                                    \"pick up milk\", \"Call dad\"),
                        tasks = c(\"laundry\", \"walk Freckles\"),
                        payments = c(rent=500, insurance=70))

  How could you reflect that in R? (Not the neighborhood but the rent increase, select all that apply)",
           answer("to_do$payments['rent'] = to_do$payments['rent'] * 1.03", correct = TRUE),
           answer("to_do$payments[1] <- to_do$payments[1] * 1.03", correct = TRUE),
           answer("to_do$payments[1] <- to_do * 1.03", correct = FALSE, message = 'The binary operator * accepts only numeric arguments, make sure you avoid passing a list as one of the arguments, R would cough at it.'),
           answer("to_do$payments[1] <- to_do$payments['rent'] * 0.03", correct = FALSE, message = "If I were you I would double check the arithmetic in one of the selections you have made before retrying."),
           answer("to_do$payments <- to_do$payments['rent'] * 1.03", correct = FALSE, message = "If this was my only feedback to you, I would have to mention that you could loose a reminder to pay insurance this month if you continue with the current selection(s)."),
           random_answer_order = TRUE,
           allow_retry = TRUE,
           correct = 'This is getting complex but you are doing just fine!',
           incorrect = "One or more incorrect selections or you are missing one or more right answer(s)? Don't get discouraged, you have come a long way at this point in your R Syntax journey!"),

  question_radio("Is a  vector more general a concept than a list in R?

  Tip: Think about the kind of data types each can store and conclude which one could be a subset of the other? Subset is more specific a concept, by contrast, the superset is a more general one.",
    answer("Yes", correct = FALSE, message = "A vector is more specific because it stores homogeneous types while a list stores hetereogeneous ones. A vector conceptually is a subset of a list because a list can be made out of a vector but not the other way around."),
    answer("No", correct = TRUE, message = "A vector is more specific because while the list can store different data type in a seemingly linear data structure, the vector can only store objects of the same type."),
    allow_retry = TRUE,
    random_answer_order = TRUE),
  question_radio(
    "Is it possible to construct a vector of class list in R?",
    answer("Yes", correct = FALSE, message = "The result of applying c() to a list would be to coerced the result to a list automatically."),
    answer("No", correct = TRUE, message = "By definition in R, a vector that contains a list already has decided to store  heterogeneous objects so it must be a list. This allows code optimizations on vectors and matrices that aren't possible on lists."),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question_checkbox("What piece of code inserts a2 at the tail of answers?

           a1 <- list(\"a\", 10, F\")
           a2 <- list(\"g\", 23, F\")
           answers <- list(a1)

  Select all that apply.",
    answer("answers <- c(answers, a2)", correct = TRUE),
    answer("answers[[2]] <- a2", correct = TRUE),
    answer("answers <- list(answers, a2)", correct = FALSE, message = "list() creates a new list with two elements, this is not what was intended."),
    answer("answers[2] <- a2", correct = FALSE, message = "Syntax moment: assignment of new elements of a list requires the use of the [[ operator."),
    answer("answers <- list(answers, list(a2))", correct = FALSE, message = "R will follow your command dutifully but somewhere you may be getting overzelous with the use of the list constructor and ended up nesting a list within another list unnecessarily!"),
    allow_retry = TRUE,
    random_answer_order = TRUE,
    correct = "You have achieved List mastery my friend!",
    incorrect = "Something is missing and/or you selected wrong answers.")

)
```

<!-- ## Data frames -->

<!-- If you have followed the data structure section then this section should be relatively easy. Like a list, data frames store information of heterogeneous type, however there are some rules: -->

<!--   - Two dimensional only, like a table. -->

<!--   - Any number of rows or columns -->

<!--   - The columns have to be of the same type and length -->

<!-- Follow these rules and data frames are an almost ideal data structure for data analysis, as convenient but safer than spreadsheets, whether in memory or saved as a file to a disk, locally or in the cloud.  -->

<!-- Data frames are similar to tables of a sophisticated relational data base, where you can store procedures (like R expressions) and even other tables in the cells. -->

<!-- ### Why is a data frame different? -->

<!-- Under the hood a data frame is implemented as a list of vectors of the same length. The algorithms to search and select items in data frames can be optimized because its two more prominent features: table-like geometry and vector columns of equal length. The elements of a vectors are stored in contiguous memory of constant size and this gives the data frame some advantages. They are natively implemented so the `$` and `[` syntax we have already covered can be safely reused for data frames. -->

<!-- ### Constructing a data frame -->

<!-- ```{r, data-frame, echo=FALSE, results='asis', dpi=96} -->

<!-- knitr::include_graphics("images/dataframe.png") -->

<!-- ``` -->

<!-- Let's create this data frame using code using the constructor function `data.frame`. -->

<!-- ```{r slice-n-dice-df, exercise=T, exercise.setup="slice-n-dice-df-setup", exercise.lines=9} -->

<!-- # using the $ operator like in a named list -->

<!-- df$country -->

<!-- df$"country" -->

<!-- # using the [] operator similar to a matrix and a vector -->

<!-- df[,1] -->

<!-- df[,"country"] -->

<!-- # using the fact that a data frame is a list under the hood -->

<!-- df[[1]] -->

<!-- df[["country"]] -->

<!-- ``` -->

<!-- *Note:* In R the dot for names has no special meaning, it is like `_`. The dot syntax for formulas and in generic object dispatch has special meaning, but those are topics for more advanced material. -->

<!-- If any of the vectors has a different length there will be error messages, R will not be happy about it. Try it for yourself in the previous exercise. -->

<!-- In the above example the vector of country names, of type `character`, was converted to factors by a default named argument `stringsAsFactors = T` in the constructor `data.frame()`. A special note about this later in this section. -->

<!-- Try the `str()` function on the data frame we just created. R has a special vocabulary for the rows and columns of a data frame. Each of the <span style="color:blue">vectors</span> in the list are mapped to a <span style="color:blue">variable</span> while each <span style="color:red">row</span> represents an <span style="color:red">observation</span>. -->

<!-- ### Subsetting a data frame -->

<!-- Similarly to subsetting vectors, we can slice and extract sections of the data frame as we please following the row, column convention and the `[]` syntax or the `$` syntax. -->

<!-- ```{r slice-n-dice-df-setup} -->

<!-- # for better documentation name the vectors -->

<!-- country <- c("Canada", "EEUU", "United Kingdom", "Germany", "Italy", "Poland") -->

<!-- population <- c(37, 331, 67, 83, 60, 39) -->

<!-- census2019 <- c(T,T,T,T,F,T) -->

<!-- df <- data.frame(country, population, census2019) -->

<!-- ``` -->

<!-- ```{r slice-n-dice-df, exercise=T, exercise.setup="slice-n-dice-df-setup", exercise.lines=9} -->

<!-- # get the $ operator -->

<!-- df$country -->

<!-- df$"country" -->

<!-- # using the [] operator -->

<!-- df[,1] -->

<!-- df[,"country"] -->

<!-- # using the fact that a data frame is a list under the hood -->

<!-- df[[1]] -->

<!-- df[["country"]] -->

<!-- ``` -->

<!-- Let's  extract all the information for Canada.  -->

<!-- ```{r subset-df-by-row-setup} -->

<!-- # for better documentation name the vectors -->

<!-- country <- c("Canada", "EEUU", "United Kingdom", "Germany", "Italy", "Poland") -->

<!-- population <- c(37, 331, 67, 83, 60, 39) -->

<!-- census2019 <- c(T,T,T,T,F,T) -->

<!-- df <- data.frame(country, population, census2019) -->

<!-- ``` -->

<!-- ```{r subset-df-by-row, exercise=T, exercise.setup="subset-df-by-row-setup", exercise.lines=1} -->

<!-- df[df$country == "Canada",] -->

<!-- ``` -->

<!-- We can extract the countries with population greater than 80 million. -->

<!-- ```{r subset-df-by-multiple-rows, exercise=T, exercise.setup="subset-df-by-row-setup,", exercise.lines=4} -->

<!-- # extract only the names of the counties  in the rows filtered -->

<!-- df[df$population > 80, 'country'] -->

<!-- # display all the columns for the rows filtered -->

<!-- df[df$population > 80,] -->

<!-- ``` -->

<!-- This way of subsetting a data frame uses what is called a **_logical mask_**. The mask is nothing but a boolean vector generated using a logical operator. The boolean vector is then used to subsetting another vector using the `[]` operator selecting the elements of the vector at the positions where the mask is `TRUE`. Since the columns of a data frame are vectors, this is a natural way of subsetting.  -->

<!-- This image helps explain it. -->

<!-- ```{r data-frame-row-filter, echo=FALSE, results='asis', fig.height=1} -->

<!-- knitr::include_graphics("images/dataframe-row-filter.png", dpi = 126) -->

<!-- ``` -->

<!-- And here is a step by step description: -->

<!--   1. Build the mask using a logical operator expressing a condition over one of the columns of the data frame. -->

<!-- ```{r explain-logical-mask-1, exercise=T, exercise.lines=1, exercise.setup="subset-df-by-row-setup"} -->

<!-- (row_filter <- df$population > 80) -->

<!-- ``` -->

<!--   2. Subset the data frame by rows using this logical mask. A `TRUE` at a given position on the mask  will let the value at that position on each row of the data frame pass _as is_. Conversely, a `FALSE` will eliminate it so it does not appear on the result. -->

<!-- ```{r explain-logical-mask-setup} -->

<!-- country <- c("Canada", "EEUU", "United Kingdom", "Germany", "Italy", "Poland") -->

<!-- population <- c(37, 331, 67, 83, 60, 39) -->

<!-- census2019 <- c(T,T,T,T,F,T) -->

<!-- df <- data.frame(country, population, census2019) -->

<!-- row_filter <- df$population > 80 -->

<!-- ``` -->

<!-- ```{r explain-logical-mask-2, exercise=T, exercise.lines=2, exercise.setup="explain-logical-mask-setup"} -->

<!-- # apply the same filter to every column of the data frame by -->

<!-- (result <- df[row_filter,]) -->

<!-- ``` -->

<!--   3. Show the column for country from the 2019 census: -->

<!-- ```{r explain-logical-mask-3-setup} -->

<!-- country <- c("Canada", "EEUU", "United Kingdom", "Germany", "Italy", "Poland") -->

<!-- population <- c(37, 331, 67, 83, 60, 39) -->

<!-- census2019 <- c(T,T,T,T,F,T) -->

<!-- df <- data.frame(country, population, census2019) -->

<!-- filter <- df$population > 80 -->

<!-- result <- df[filter,] -->

<!-- ``` -->

<!-- ```{r explain-logical-mask-3, exercise=T, exercise.lines=2, exercise.setup="explain-logical-mask-3-setup"} -->

<!-- # apply the filter to all the vectors of the data frame -->

<!-- result[c("country", "population")] -->

<!-- ``` -->

<!-- ### Reusing your knowledge of R Syntax -->

<!-- At this point in your R Syntax journey you may start to appreciate that some patterns. Here is an image taken from @BaseR-Cheatsheet that might show some of these patterns. -->

<!-- ```{r, data-frame-sheat-sheet-example, echo=FALSE, results='asis'} -->

<!--   knitr::include_graphics("images/Dataframe_shortcuts_from_BaseR_Cheat_Sheet.png", dpi = 96) -->

<!-- ``` -->

<!-- As a very special case of a list, you would expect to be able to reuse some of your list manipulation knowledge, right? In a similar way, with the _table-like_ shape you would expect to be able to re-use some of your knowledge of `cbind` and `rbind`, correct? -->

<!-- ### The subsetting function -->

<!-- The built-in function `subset` takes a data frame and returns a new object with the requested data frame. This function receives a logical vector as named parameter `subset` with `TRUE` for elements that should be included and `FALSE` otherwise. Another optional parameter called `select` is a vector with the column positions or names to include by default, unless a third parameter called `drop` is set to TRUE, in which case the selected values are dropped from the resulting subset. -->

<!-- As an example let's take the time series for quarterly earnings per share for Johnson and Johnson from 1960 to 1980, part of the `datasets` package included in modern default R installations. We are  asked to extract the years when the last quarter earnings were greater than 60% of the annual earning per share and show the last quarter and the total earnings. -->

<!-- ```{r, example-using-subset-function, exercise=T, exercise.lines=11} -->

<!-- # create  a data frame based on the time series using coercion from 'ts' to matrix -->

<!-- (J_and_J <- data.frame( matrix(JohnsonJohnson,  -->

<!--                               ncol=4,  -->

<!--                               dimnames = list( 1960:1980, c("Qtr1", "Qtr2", "Qtr3", "Qtr4"))))) -->

<!-- # add a new column with the annual earnings -->

<!-- J_and_J <- cbind(J_and_J, Annual=rowSums(J_and_J)) -->

<!-- # create a vector with the 4th quarter earnings as a percentage of the annual earnings  -->

<!-- Qtr4_percent <- J_and_J$Qtr4 / J_and_J$Annual * 100 -->

<!-- # subset by row using a logical vector and show  the required columns  in one step -->

<!-- # J_and_J[Qtr4_percent > 60, c(4,5)] # using base-R syntax -->

<!-- subset(J_and_J, subset = Qtr4_percent > 60, select = c(4,5)) # using built-in function -->

<!-- ``` -->

<!-- That was a company on a roll in the 70's! -->

<!-- **Note:** this function is one of the few that exposes a behaviour called non-standard evaluation in R. That means that when setting the arguments on a call of the function the argument can be interpreted as a character string first if it exists. They are very convenient in interactive work at the command line (the REPL, [Read-evaluate-print-loop](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop), as it is known) because you have in mind what you are interacting with but on a written script it may lead to out of context interpretations. The best practice is not to use `subset` in programs. The packages derived from the seminal work of Wickham [@tidy-data] provide consistent syntax to do these and many more operations on data.    -->

<!-- ### Subsetting and transforming at the same time -->

<!-- A very common operation on data frames is to aggregate the values in one or more columns of observations that belong to the same category. The nature of the aggregation can be an operation like counting, adding, or by extension, applying any function that takes a value and returns it in a transformed state. -->

<!-- First create a data frame with some results from an fictional experiment that was done by triplicate. -->

<!-- ```{r, aggregating-examples, exercise=T, exercise.lines=7} -->

<!-- set.seed(5529) -->

<!-- treatment <- LETTERS[sample(x = 1:26, size = 2)] # vector to be recycled by data frame -->

<!-- results <- round(runif(6), digits = 2) -->

<!-- passes <- results>0.7 -->

<!-- (df <- data.frame(treatment=treatment,  -->

<!--                  val_1=results, -->

<!--                  passes=passes)) -->

<!-- ``` -->

<!-- Then subset by treatment while adding `Val_1` and counting the number of observations that are greater than `0.7`. -->

<!-- ```{r, aggregation-examples-setup} -->

<!-- set.seed(5529) -->

<!-- treatment <- LETTERS[sample(x = 1:26, size = 2)] # vector to be recycled by data frame -->

<!-- results <- round(runif(6), digits = 2) -->

<!-- passes <- results>0.7 -->

<!-- df <- data.frame(treatment=treatment,  -->

<!--                  val_1=results, -->

<!--                  passes=passes) -->

<!-- ``` -->

<!-- ```{r, aggregation-example-adding, exercise=T, exercise.lines=12, exercise.setup="aggregation-examples-setup"} -->

<!-- # first calculate the mean of val_1 by treatment -->

<!-- (val_1_by_treatment <- aggregate(x = df$val_1, -->

<!--                                  by = list(df$treatment),  -->

<!--                                  FUN = "mean")) -->

<!-- # the calculate the number of results that are greater than 0.7 -->

<!-- (num_gt_point_seven_by_treatment <- aggregate(x = df$passes,  -->

<!--                                      by = list(df$treatment),  -->

<!--                                      FUN = "sum")) -->

<!-- # now put them together in a single data frame -->

<!-- aggregated_df <- cbind(val_1_by_treatment, num_gt_point_seven_by_treatment$x) -->

<!-- names(aggregated_df) <- c("treatment", "mean_val_1", "num_gt_0_pt_7") -->

<!-- aggregated_df -->

<!-- ``` -->

<!-- ### Factors or strings -->

<!-- Did you notice that in the previous section we got the countries as a vector of factors with 6 levels? Remember that special case of vectors called factors specialized on manipulating categorical variables? Well here we go again.  -->

<!-- When you construct a data frame from vectors the type, or class, of  each vector will be interpreted by the data frame constructor. R will try to coerce all the elements of the vector to the most general data type to be able to work with them. An ordering of types from more  general to more specific is `character` > `complex` > `double` > `integer` > `logical`.  -->

<!-- You can give R hints, though, for instance you can tell it to interpret the strings in vectors as factors or not, base R will do it by default. -->

<!-- ```{r example-data-frame-strings-as-factors, exercise=T, exercise.lines=7} -->

<!-- country <- c("Canada", "EEUU", "United Kingdom", "Germany", "Italy", "Poland") -->

<!-- population <- c(37, 331, 67, 83, 60, 39) -->

<!-- # strings as factors is the default -->

<!-- country_stats <- data.frame( country, -->

<!--                              population, stringsAsFactors = TRUE) -->

<!-- # the function 'str()' shows us the structure of the object -->

<!-- str(country_stats) -->

<!-- ``` -->

<!-- The R constructor for data frames interpreted the strings as 6 factors. Perhaps not what you expected, compare with this case. -->

<!-- ```{r example-data-frame-strings-as-is-setup} -->

<!-- country <- c("Canada", "EEUU", "United Kingdom", "Germany", "Italy", "Poland") -->

<!-- population <- c(37, 331, 67, 83, 60, 39) -->

<!-- ``` -->

<!-- ```{r example-data-frame-strings-as-is, exercise=T, exercise.lines=2, exercise.setup="example-data-frame-strings-as-is-setup"} -->

<!-- country_stats <- data.frame( country, population, stringsAsFactors = FALSE) -->

<!-- str(country_stats) -->

<!-- ``` -->

<!-- ### NAs in a data frame -->

<!-- Because each row on a data frame is associated with an experimental observation of some sort, sometimes an observation may genuinely have missing entries for some of the variables that were simply not measured or are not available in the data set. The function `is.na()` can be used on the whole data frame to return a data frame of logical vectors with `TRUE`  if an `NA` exists at that position or `FALSE` otherwise. The function `complete.cases()` identifies the observations with missing values.  -->

<!-- Some mathematical operations may create values that are not amenable to be further processed, for example dividing 0/0 or any number by 0, in the first case the result is `NaN` and in the second `Inf`.  -->

<!-- An exercise will clarify the identification of all these values. -->

<!-- ```{r, detect-NAs-in-a-data-frame, exercise=T, exercise.lines=15} -->

<!-- set.seed(7777) -->

<!-- (df <- data.frame(experiment=rep(LETTERS[1:3], each=3),  -->

<!--                   run=rep(1:3,3),  -->

<!--                   results=round(runif(n = 9, min = 0.0, max = 10.0), digits = 2))) -->

<!-- # introduce some NA, NaN, Inf -->

<!-- df$results[c(3,5,8)] <- c(NA, NaN, Inf)  -->

<!-- # find if there are any missing values -->

<!-- any(is.na(df) | is.infinite(df$results)) -->

<!-- # Find what observations are missing values.  -->

<!-- # First get a logical vector to be used as filter for the rows with incomplete cases -->

<!-- missing_values <- !complete.cases(df)  -->

<!-- # then get a filter for the cases with infinite values -->

<!-- infinites <- is.infinite(df$results) -->

<!-- # now filter out those observations -->

<!-- df[(missing_values | infinites),] -->

<!-- ``` -->

<!-- ### Test your knowledge -->

<!-- ```{r quiz-data-frames, echo=FALSE, cache=FALSE} -->

<!-- quiz( -->

<!--   question_checkbox(" -->

<!--   What code subsets the rows with missing values from this data frame?   -->

<!--       df <- data.frame(obs=LETTERS[1:5], -->

<!--                        results=as.numeric(c(\"3.5\", \"1.9\", \"3.9\", \"5..4\", \"3.8\"))) -->

<!--   Select all that apply)", -->

<!--            answer("df[is.na(df$results),]", correct = TRUE), -->

<!--            answer("df[!complete.cases(df),]", correct = TRUE), -->

<!--            answer("df[,is.na(df)]", correct = FALSE, message = 'Filtering columns, that is variables, might not be a good approach here!'), -->

<!--            answer("!df[[complete.cases(df)]]", correct = FALSE, message = "I must admit some of these options are just gibberish, be warned."), -->

<!--            answer("df[complete.cases(df),]", correct = FALSE, message = "The answer has to answer the exact question, a second read might clarify the target."), -->

<!--            random_answer_order = TRUE, -->

<!--            allow_retry = TRUE, -->

<!--            correct = 'This has been the most complicated subsetting question you have solved today, pat yourself in the back!', -->

<!--            incorrect = "One or more correct answers may be missing and/or you have selected wrong answers, in the former case more information follows."), -->

<!--   question( -->

<!--     "How many variables and observations are there in this data frame? -->

<!--       n <- 10 -->

<!--       df <- data.frame(x=1:n, y = runif(n)) -->

<!--       df <- cbind(df, pass = df$y > 0.9) -->

<!-- The 'runif' functions computes n random values from a uniformly distributed variable between 0 and 1.0", -->

<!--   answer("3 variables and 10 observations", correct = TRUE), -->

<!--   answer("10 observations and 3 variables", correct = FALSE, message = 'I would reconsider this option.'), -->

<!--   answer("10 variables and 2 observations", correct = FALSE, message = 'Have you tried to run the code on an exercise sandbox?'), -->

<!--   answer("2 variables, 10 observations, 1 condition", correct = FALSE, message = 'Something is not right with this answer, I would leave the way variables are calculated out of it.'), -->

<!--   answer("2 variables and 11 observations", correct = FALSE, message = 'May I suggest you identify how many columns this data frame will have after the two lines are executed?'), -->

<!--   random_answer_order = TRUE, -->

<!--   allow_retry = TRUE, -->

<!--   correct = 'Bravo! I see you are starting to speak R quite fluently.' -->

<!--   ), -->

<!--   question_radio( -->

<!--     "Data frames were designed as a list of atomic vectors.", -->

<!--   answer("True", correct = FALSE, message = 'The correct answer is a list of any vectors, atomic or lists'), -->

<!--   answer("False", correct = TRUE, message = 'Is this is your first choice and you feel sure about it, I must admit you are solid on data frame theory principles.'), -->

<!--   random_answer_order = TRUE, -->

<!--   allow_retry = TRUE), -->

<!--   question_radio( -->

<!--     "Can a data frame store lists in its columns?", -->

<!--   answer("Yes", correct = TRUE, message = 'As a followup to the previous question, if data frames can store vectors of heterogeneous elements, those are precisely lists, congratulations!'), -->

<!--   answer("No", correct = FALSE, message = 'Remember that a vector can be of  type atomic or list and a data frame can store any vector.'), -->

<!--   random_answer_order = TRUE, -->

<!--   allow_retry = TRUE), -->

<!--   question_radio( -->

<!--     "Can a data frame store other data frames in its columns?", -->

<!--   answer("Yes", correct = TRUE, message = 'By definition lists are recursive data structures, meaning they can store instances of its own type as elements, so this is the right answer because data frames are lists of vectors of the same length.'), -->

<!--   answer("No", correct = FALSE, message = 'Data frames are based upon a list of vectors and lists by definition can store other lists, therefore  this is the incorrect answer.'), -->

<!--   random_answer_order = TRUE, -->

<!--   allow_retry = TRUE), -->

<!--   question( -->

<!--     "Select the code that subsets the population of the countries with the smallest population that were included by the 2019 census: -->

<!--       country <- c(\"Canada\", \"EEUU\", \"UK\", \"Germany\", \"Italy\", \"Poland\") -->

<!--       population <- c(37, 331, 67, 83, 60, 39) -->

<!--       census2019 <- c(T,T,T,T,F,T) -->

<!--       df <- data.frame(country, population, census2019) -->

<!--   ", -->

<!--   answer("df[df$population == min(df$population) & census2019==TRUE,]$population", correct = TRUE), -->

<!--   answer("df[df$population == min(df$population) & census2019==TRUE,]", correct = FALSE, message = 'The question is very specific, perhaps you are missing an extra bit of code.'), -->

<!--   answer("df[min(df$population) & census2019==TRUE,]", correct = FALSE, message = 'This would not work as intended because the function min returns a vector of length 1 that gets recycled as a TRUE value to match the length of the census2019 vector, try it.'), -->

<!--   answer("df[,df$population<min(df$population) & census2019==TRUE]]", correct = FALSE, message = 'We are subsetting by rows so the conditions should be placed on rows, the first parameter to the [ operator, just like in matrix subsetting.'), -->

<!--   random_answer_order = TRUE, -->

<!--   allow_retry = TRUE, -->

<!--   correct = "You got it, the R subsetting syntax of vectors and matrices nicely extends to data frames!") -->

<!-- ) -->

<!-- ``` -->

<!-- ## User functions -->

<!-- If you start writing a lot of R code, sooner or later you will find the need to reuse the same functionality over and over. Functions help you package that functionality in a single scope and reuse it in a convenient form. -->

<!-- A user function behaves like a built-in function, although their scopes (the environments where they operate) are different. -->

<!-- The values that the function receives are called <span style=color:blue">parameters</span>  in the definition of the function. The values actually passed to the function  when called are called <span style=color:blue">arguments</span>. -->

<!-- ### How to write a user-defined function -->

<!-- In R the body of a function is written between curly braces and the last statement is the returned value. -->

<!-- Now write a function that adds any two numbers and then call it. -->

<!-- ```{r add-function, exercise=TRUE, exercise.lines = 3} -->

<!-- add2numbers <- function(a, b) { -->

<!-- } -->

<!-- ``` -->

<!-- ```{r add-function-hint} -->

<!-- add2numbers <- function(a, b) { -->

<!--   return(a + b) -->

<!-- } -->

<!-- ``` -->

<!-- An R user-defined function is called exactly the way you would call a built-in function. -->

<!-- ```{r, calling-a-user-defined-function-setup} -->

<!-- add2numbers <- function(a, b) { -->

<!--   return(a + b) -->

<!-- } -->

<!-- ``` -->

<!-- ```{r, calling-a-user-defined-funciton, exercise=T, exercise.lines=1, exercise.setup="calling-a-user-defined-function-setup"} -->

<!-- (result <- add2numbers(5, 4)) -->

<!-- ``` -->

<!-- The value returned by a function is the one defined by the last expression within the function body. The `return` is not necessary. -->

<!-- ```{r, calling-a-user-defined-funciton-simple, exercise=T, exercise.lines=4} -->

<!-- add_2_numbers <- function(a, b) { -->

<!--   a + b -->

<!-- } -->

<!-- (result_2 <- add_2_numbers(5, 4)) -->

<!-- ``` -->

<!-- **Note: ** A user-defined function that modifies an object creates a copy of  it  before affecting it. If the object was passed from the environment where the function was created then it will maintain all references to it unchanged but it will be a copy in memory nonetheless. Only primitive functions modify objects without making copies. That is why to make the fastest possible user-defined R function try to reuse as many primitive functions as you can to write its functionality. -->

<!-- ### Named parameters -->

<!-- Just like with built-ins you can name parameters. You can also use default values. -->

<!-- ```{r, named-parameters-in-user-defined-functions, exercise=T, exercise.lines=9} -->

<!-- add_2_vectors <- function(x, y) { -->

<!--   sum(x, y) -->

<!-- } -->

<!-- # now use the function -->

<!-- set.seed(1234) -->

<!-- (a <- sample(c(1:100), size = 10, replace = T)) -->

<!-- (b <- c(sample(c(1:100), 4, T), NA, c(sample(c(1:100), 5, T)))) -->

<!-- add_2_vectors(x = a, -->

<!--               y = b) -->

<!-- ``` -->

<!-- We might want to fix this hiccup by adding a default parameter to indicate that if `NA`s are found they can be safely ignored. -->

<!-- ```{r, named-parameters-in-user-defined-functions-NAs-addressed-setup} -->

<!-- set.seed(1234) -->

<!-- a <- sample(c(1:100), size = 10, replace = T) -->

<!-- b <- c(sample(c(1:100), 4, T), NA, c(sample(c(1:100), 5, T))) -->

<!-- ``` -->

<!-- ```{r, named-parameters-in-user-defined-functions-NAs-addressed, exercise=T, exercise.lines=4, exercise.setup="named-parameters-in-user-defined-functions-NAs-addressed-setup"} -->

<!-- add_2_vectors <- function(x, y, remove.na = TRUE) { -->

<!--   sum(x, y, na.rm = remove.na) -->

<!-- } -->

<!-- add_2_vectors(x = a, y = b) -->

<!-- ``` -->

<!-- Most R functions have parameters to ignore the presence of missing values when processing the input. -->

<!-- ## Control of execution -->

<!-- For a program or a function to do interesting calculations it is necessary to operate repetitively over data structures like vectors and lists to generate new values or a single one representing the desired target. -->

<!-- The line by line flow of execution of an R program can be altered with the use of functions or statements. Both methods are available in R.  Using functions leads to a functional style of programming while using statements leads to procedural style. -->

<!-- ### The procedural statements -->

<!-- The procedural style syntax for looping or iterating uses the following structures: -->

<!-- ```{r, if-statement,  eval=FALSE, echo=TRUE, include=TRUE} -->

<!-- if (condition) { -->

<!--   Do something -->

<!-- } else { -->

<!--   Do something different -->

<!-- } -->

<!-- ``` -->

<!-- ```{r while-statement, eval=FALSE,  echo=TRUE, include=TRUE} -->

<!-- while (condition) { -->

<!--   Do something -->

<!-- } -->

<!-- ``` -->

<!-- ```{r for-statement, eval=FALSE,  echo=TRUE, include=TRUE} -->

<!-- for (variable in sequence) { -->

<!--   Do something -->

<!-- } -->

<!-- ``` -->

<!-- ### The functional style -->

<!-- The functional forms of these structures can be formulated depending on the object that the user-function is applied to. For a vector the applications are straight forward. -->

<!-- The functional and procedural styles of writing programs are  equivalent, however for the majority of the applications in statistics and linear algebra R is optimized to use the functional style. More recently packages like `purr` from the `tidyverse` syntax have added all the functional tools that make it extremely succinct to express standard transformations on vectorized data structures like lists, matrices, arrays, and data frames. -->

<!-- Let's have a look at concrete examples. -->

<!-- ### Iterating  over a vector -->

<!--  First illustrate the  `sapply` function to square all the elements of a numeric vector. -->

<!-- ```{r, sapply-example-on-vector, exercise=T, exercise.lines=4} -->

<!-- set.seed(456) -->

<!-- v <- runif(5, 1, 5) -->

<!-- # now iterate over the vector applying your operation to square each element -->

<!-- (squares2 <- sapply(v, function(a) {a*a})) -->

<!-- ``` -->

<!-- ```{r, sapply-vs-for-loop-comparison-setup} -->

<!-- set.seed(456) -->

<!-- v <- runif(5, 1, 5) -->

<!-- ``` -->

<!-- Now use the for-loop to achieve the same transformation. -->

<!-- ```{r, for-loop-example-on-vector, exercise=T, exercise.lines=9, exercise.setup="sapply-vs-for-loop-comparison-setup"} -->

<!-- # pre-allocate space in the vector -->

<!-- square_vals <- rep(0, length(v)) -->

<!-- i = 1 -->

<!-- for (a in v) { -->

<!--   square_vals[i] = a*a -->

<!--   i = i + 1 -->

<!-- } -->

<!-- # display the answer -->

<!-- square_vals -->

<!-- ``` -->

<!-- ### Conditionally removing values from a vector -->

<!-- In functional style this is done via subsetting. In procedural style  a combination of a for-loop and the conditional-statements with if-else can achieve the same result. Let us have a look at the air fare to sun destinations at or below $1200. -->

<!-- ```{r, conditionally-removing-with-filter, exercise=T, exercise.lines=2} -->

<!-- air_fares <- c(Habana=1200, Cancun=1150, Los_cabos=960, Costa_Rica=1250) -->

<!-- (results <- air_fares[air_fares <= 1200]) -->

<!-- ``` -->

<!-- Now let's do it in procedural style. -->

<!-- ```{r, conditionally-removing-with-for-loop-and-if-statement-setup} -->

<!-- air_fares <- c(Habana=1200, Cancun=1150, Los_cabos=960, Costa_Rica=1250) -->

<!-- ``` -->

<!-- ```{r, conditionally-removing-with-for-loop-and-if-statement, exercise=T, exercise.lines=9, exercise.setup="conditionally-removing-with-for-loop-and-if-statement-setup"} -->

<!-- results <- c() -->

<!-- if (length(air_fares) > 0) { -->

<!--   n <- length(air_fares) -->

<!--   for (i in 1:n) { -->

<!--     if (air_fares[i] <= 1200) { -->

<!--       results <- c(results, air_fares[i]) -->

<!--     } -->

<!--   } -->

<!-- } -->

<!-- results -->

<!-- ``` -->

<!-- =============================== -->

## License

<!-- =============================== -->

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons License" style="border-width:0"/></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

<!-- =============================== -->

## Tutorials & online-resources

<!-- =============================== -->

General:

1.  <https://cran.r-project.org/manuals.html> (all of them)
2.  <https://statisticsglobe.com/r-programming-language> [@StatisticsGlobe]
3.  <https://datacarpentry.org/R-ecology-lesson/01-intro-to-r.html> [@TheCarpentries.org.home]
4.  <https://cran.r-project.org/doc/manuals/r-release/R-intro.html> (Introduction)
5.  <https://www.burns-stat.com/pages/Tutor/R_inferno.pdf> [@TheRInferno] (no sugar coating) <!-- 6. http://courtneybrown.com/YouTube/R_Tutorial_Videos.html (time-proven simple explanations) -->

Computing:

1.  <http://adv-r.had.co.nz/> (Free access to Advanced R book by Wickham himself)
2.  <https://cran.r-project.org/doc/manuals/r-release/R-exts.pdf> (writing R packages)
3.  <https://cran.r-project.org/doc/manuals/r-release/R-ints.html> (low level language details)
4.  <https://www.stat.berkeley.edu/~s133/> [@UBerkeleyS133.ConceptsComputeWithData]

<!-- Data cleaning: -->

<!-- 1. https://cran.r-project.org/doc/contrib/de_Jonge+van_der_Loo-Introduction_to_data_cleaning_with_R.pdf -->

Statistics:

1.  <https://www.stat.berkeley.edu/~spector/s243/>
2.  <https://www.bioconductor.org/> (for bio-statistics)

Language Reference:

1.  <https://cran.r-project.org/doc/manuals/r-release/fullrefman.pdf> (latest)

<!-- =============================== -->

## References

<!-- =============================== -->
